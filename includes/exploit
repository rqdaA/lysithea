#!/bin/bash
[ -n "$H_GUARD_EXPLOIT" ] && return
readonly H_GUARD_EXPLOIT=1

source "$(realpath $(dirname $0))/includes/errors"
source "$(realpath $(dirname $0))/includes/utils"
source "$(realpath $(dirname $0))/includes/gitter"
source "$(realpath $(dirname $0))/includes/fs"



# configs

EXPLOIT=exploit
SENDER=sender.py
EXPLOIT_PATH=/

ALPINE_DOCKER_IMAGE=lysithea-remote-builder
ALPINE_DOCKER_CONTAINER="$ALPINE_DOCKER_IMAGE"-instance

# funcs

function exploit_local() {
  echo "[+] starting exploit localy..."
  _run_qemu
}

function compile_exploit() {
  read_config "INCLUDE"
  if [ -z "$INCLUDE" ]; then
    INCLUDE=""
  fi

  echo "[+] compiling exploit..."
  # compile and copy exploit
  gcc "$EXPLOIT".c -o "$EXPLOIT" \
    --static \
    -g \
    -O0 \
    -masm=intel \
    -pthread \
    $INCLUDE \
    || _error_exit $COMPILE_ERROR "compile error"

  read_config "ROOTFS"
  [ -z $ROOTFS ] && _error_exit "ROOTFS config not found"
  filetype=$(check_filesystem_type $ROOTFS)
  if [ $filetype == "$FILETYPE_EXT4" ]; then
    vecho "[.] (EXT4) mounting $ROOTFS on $EXTRACTED to copy exploit."
    sudo mount $ROOTFS $EXTRACTED
    vecho "[.] copying exploit."
    cp $EXPLOIT "$EXTRACTED/$EXPLOIT_PATH" || {
      echo "[!] copying exploit as root..."
      sudo cp $EXPLOIT "$EXTRACTED/$EXPLOIT_PATH"
    }
    vecho "[.] unmounting $EXTRACTED."
    sudo umount $EXTRACTED
  elif [ $filetype == "$FILETYPE_QCOW" ]; then
    if [ "$(ls -la "$EXTRACTED" | wc -l)" -le "3" ]; then
      echo "[.] (QCOW2) mounting $ROOTFS on $EXTRACTED to copy exploit."
      extract_filesystem_qcow
    fi
    echo "[.] copying exploit in mounted QCOW2 filesystem."
    cp $EXPLOIT "$EXTRACTED/$EXPLOIT_PATH" || {
      echo "[!] copying exploit as root..."
      sudo cp $EXPLOIT "$EXTRACTED/$EXPLOIT_PATH"
    }
  else
    cp $EXPLOIT "$EXTRACTED/$EXPLOIT_PATH"
  fi
}

function build_compressed_exploit() {
  echo "[+] compiling compressed exploit..."

  local image_existing="$(docker images | grep $ALPINE_DOCKER_IMAGE)"
  if [ -z "$image_existing" ]; then
    echo "[+] building docker image to build with musl-libc..."
    echo -e "  (this might take some minutes, but don't worry this is first-time only)"
    docker build -t "$ALPINE_DOCKER_IMAGE" - < "$IAMDIR"/build/Dockerfile
  fi
  docker container run \
    -it \
    --name "$ALPINE_DOCKER_CONTAINER" \
    --rm \
    -v "$PWD:$PWD" \
    -w "$PWD" \
    "$ALPINE_DOCKER_IMAGE" /bin/sh -c "gcc $CPPFLAGS $EXPLOIT.c -o $EXPLOIT --static"
  strip "$EXPLOIT"
  gzip "$EXPLOIT"
  base64 "$EXPLOIT".gz > "$EXPLOIT".gz.b64
  rm -f "$EXPLOIT".gz
}

function exploit_remote() {
  echo "[+] starting exploit remotely..."

  read_config "EXPLOIT_HOST"
  read_config "EXPLOIT_PORT"
  if [ -z "$EXPLOIT_HOST" ] ; then
    _error_exit "$CONFIG_INVALID" "\$EXPLOIT_HOST is not specified in configuration"
  fi
  if [ -z "$EXPLOIT_PORT" ] ; then
    _error_exit "$CONFIG_INVALID" "\$EXPLOIT_PORT is not specified in configuration"
  fi

  if [ -z "$EXPLOIT_SKIP_BUILD" ]; then
    build_compressed_exploit
  else
    echo "[.] skipping build"
  fi

  EXPLOIT_BIN="$EXPLOIT".gz.b64 EXPLOIT_HOST="$EXPLOIT_HOST" EXPLOIT_PORT="$EXPLOIT_PORT" python2 $SENDER r
}

function exploit() {
  if [ -z "$EXPLOIT_DONT_LOG" ]; then
    hook_exploit
  fi

  if [ -n "$EXPLOIT_LOCAL" ]; then
    if [ -z "$EXPLOIT_SKIP_BUILD" ] || [ "$EXPLOIT_SKIP_BUILD" -eq 0 ]; then
      # In case ROOTFS is already compressed, we need to create temporary directory
      compile_exploit
      compress_filesystem
    fi
    exploit_local | tee "$LYSITHEA_HISTORY"
    exploit_callback # in case QEMU quits normally
  else
    exploit_remote | tee "$LYSITHEA_HISTORY"
  fi
}

function _run_qemu() {
  read_config "QEMUSCRIPT"

  if [ -z "$QEMUSCRIPT" ]; then
    _error_exit "$CONFIG_INVALID" "specify which qemu script to run"
  fi

  if ! [ -f "$QEMUSCRIPT" ]; then
    _error_exit "$FILE_NOT_FOUND" "QEMU script not found: '$QEMUSCRIPT'"
  fi

  bash "$QEMUSCRIPT"
}
